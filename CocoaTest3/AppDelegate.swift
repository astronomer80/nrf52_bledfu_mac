//
//  AppDelegate.swift
//  #CocoaApplication to Scan BLE devices with DFU Service and to perform the DFU via BLE using iOSDFULibrary.framework
//
//  Created by Angelo Ferrante on 1/10/17.
//  Copyright Â© 2017 Arduino S.r.l. All rights reserved.
//

import Cocoa
import iOSDFULibrary
import CoreBluetooth
import Darwin

//var verbosemode=true
var verbosemode=true
var updatemode=false
var zipmode=false
var dfuperformed=false

var binfile: String!
var datfile: String!
var zipfile: String!
var device_address: String!


@NSApplicationMain
class AppDelegate: NSObject, NSApplicationDelegate, CBCentralManagerDelegate, CBPeripheralDelegate {
    /**
     Callback function that runs when the app is completely launched
     It read the arument parameters passed and perform the proper action
     */
    func applicationDidFinishLaunching(_ aNotification: Notification) {
        readParameters()
    }
    
    /**
     Read CommandLine arguments and perform the proper action
     */
    func readParameters(){
        logDebug(message: "readParams")

        for argument in CommandLine.arguments {
            switch argument {
            case "verbose", "-v":
                logWrite(message: "Verbose mode ON")
                verbosemode=true

            case "help":
                logWrite(message: "OTA DFU update application for nrf5x MCUs. Visit https://github.com/astronomer80/nrf52_bledfu_mac for more information")
                logWrite(message: "Here a list of commands available:")
                logWrite(message: "help: Show this help")
                logWrite(message: "scan: Scan BLE devices already paired with Windows Settings")
                logWrite(message: "update -f < hex_file/bin_file > -d < dat_file > -a <device_address>. bin_file is the file generated from the Arduino IDE. dat_file is the init packet generated by nrfutil application. device_address: is the address (UUID) of the device returned using scan command.")
                logWrite(message: "update -z < zip_file > -a <device_address>. zip_file is the archive generated by nrfutil application. device_address: is the address of the device returned using 'scan' command.")
                logWrite(message: "update -h < hex_file/bin_file > -a <device_address>. hex_file or the bin_file is generated by the Arduino IDE. nrfutil application generates the zip archive. device_address: is the address (UUID) of the device returned using 'scan' command.");
                exit(0)
            case "scan":
                print("Scan")
                centralManager = CBCentralManager(delegate: self, queue: nil)
            case "update":
                updatemode=true
                print("Update")
                if(CommandLine.arguments.contains("-f") && CommandLine.arguments.contains("-d") && CommandLine.arguments.contains("-a")){
                    binfile=CommandLine.arguments[CommandLine.arguments.index(of: "-f")!+1]
                    datfile=CommandLine.arguments[CommandLine.arguments.index(of: "-d")!+1]
                    device_address=CommandLine.arguments[CommandLine.arguments.index(of: "-a")!+1]

                    logDebug(message: "binfile: " + binfile)
                    logDebug(message: "datfile: " + datfile)
                    logDebug(message: "device_address: " + device_address)

                    centralManager = CBCentralManager(delegate: self, queue: nil)
                }else if(CommandLine.arguments.contains("-z") && CommandLine.arguments.contains("-a")){
                    zipmode=true
                    zipfile=CommandLine.arguments[CommandLine.arguments.index(of: "-z")!+1]
                    device_address=CommandLine.arguments[CommandLine.arguments.index(of: "-a")!+1]
                    
                    logDebug(message: "zipfile: " + zipfile)
                    logDebug(message: "device_address: " + device_address)
                    
                    centralManager = CBCentralManager(delegate: self, queue: nil)
                }
                
                else{
                    logWrite(message: "Invalid  parameters")
                }
                
            default:
                let a=0
                //logDebug(message: "an argument "  + argument);
            }
        }
    }

    /**
     Write the log file only in verbose mode
     */
    func logDebug(message: String){
        if (verbosemode==true){
            logWrite(message: message)
        }
    }

    /**
     * Write the @parameters message on the log file
     */
    func logWrite(message: String){
        print (message)
        let fileURL = try! FileManager.default.url(for: .documentDirectory, in: .userDomainMask, appropriateFor: nil, create: false)
            .appendingPathComponent("nrf_bledfu_mac_output.txt")
        
        if let outputStream = OutputStream(url: fileURL, append: true) {
            outputStream.open()
            let text = message + "\n"
            let bytesWritten = outputStream.write(text, maxLength: text.lengthOfBytes(using: String.Encoding.utf8))
            if bytesWritten < 0 { print("write failure") }
            outputStream.close()
        } else {
            print("Unable to open log file")
        }
    }
    
    //MARK: - Class properties
    var centralManager              : CBCentralManager!
    var legacyDfuServiceUUID        : CBUUID
    var secureDfuServiceUUID        : CBUUID
    var selectedPeripheral          : CBPeripheral!
    var selectedPeripheralIsSecure  : Bool?
    var discoveredPeripherals       : [CBPeripheral]?
    var securePeripheralMarkers     : [Bool]?
    
    required override init() {
        //Initialize CentralManager and DFUService UUID
        centralManager = CBCentralManager()
        legacyDfuServiceUUID    = CBUUID(string: "00001530-1212-EFDE-1523-785FEABCD123")
        secureDfuServiceUUID    = CBUUID(string: "FE59")
        //super.init(coder: aDecoder)
        super.init()
        centralManager.delegate = self
        discoveredPeripherals = [CBPeripheral]()
        securePeripheralMarkers = [Bool]()
    }
    
    
    func centralManagerDidUpdateState(_ central: CBCentralManager) {
        //if central.state == CBCentralManagerState.poweredOn {
        //centralManager.scanForPeripheralsWithServices(nil, options: nil)
        logDebug(message: "centralManagerDidUpdateState")
        
        switch (central.state)
        {
        case.unsupported:
            logWrite(message: "BLE is not supported")
            exit(0)
        case.unauthorized:
            logWrite(message:"BLE is unauthorized")
            exit(0)
        case.unknown:
            logWrite(message:"BLE is Unknown")
            exit(0)
        case.resetting:
            logWrite(message:"BLE is Resetting")
            exit(0)
        case.poweredOff:
            logWrite(message:"BLE service is powered off")
            exit(0)
        case.poweredOn:
            logWrite(message:"BLE service is powered on. Scanning for peripherals...")
            centralManager.scanForPeripherals(withServices: nil, options: nil)
        default:
            logWrite(message: "default state")
            
        }
    }
    
    /**
     Start DFU procedure
     */
    func startDFU(){
        logDebug(message: "Starting DFU for device address " + device_address )

        let selectedFirmware: DFUFirmware
        if(zipmode){
            let zipUrl = URL(string: "file://" + zipfile)
            selectedFirmware = DFUFirmware(urlToZipFile:zipUrl!)!
        }else{
            let url = URL(string: "file://" + binfile)
            let datUrl = URL(string: "file://" + datfile)
            selectedFirmware = DFUFirmware(urlToBinOrHexFile: url!, urlToDatFile: datUrl!, type: DFUFirmwareType.application)!
        }
        //let initiator = DFUServiceInitiator(centralManager: self.centralManager, twet: self.selectedPeripheral).withFirmwareFile(selectedFirmware)
        
        let initiator = DFUServiceInitiator(centralManager: self.centralManager!, target: self.selectedPeripheral)
        initiator.with(firmware: selectedFirmware)
        // Optional:
        //initiator.forceDfu = true;
        //initiator.logger
        
        //initiator.forceDfu = true/false; // default false
        // initiator.packetReceiptNotificationParameter = N; // default is 12
        //        initiator.logger = self; // - to get log info
        //        initiator.delegate = self; // - to be informed about current state and errors
        //        initiator.progressDelegate = self; // - to show progress bar
        // initiator.peripheralSelector = ... // the default selector is used
        
        let controller = initiator.start()
        
        //print("Progress \(initiator.s)")
        
        logWrite(message: "End DFU. Restarting device...")
        
        //exit(0)
    }
    
    
    //    func centralManagerDidUpdateState(central: CBCentralManager!) {
    //
    //    }
    //
    // Launched when the application starts
    func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) {
        logDebug(message: "Scanning...");
        //If a BLE device is found
        if advertisementData[CBAdvertisementDataServiceUUIDsKey] != nil {
            //Secure DFU UUID
            let secureUUIDString = CBUUID(string: "FE59").uuidString
            let advertisedUUIDstring = ((advertisementData[CBAdvertisementDataServiceUUIDsKey]!) as AnyObject).firstObject as! CBUUID
            if advertisedUUIDstring.uuidString  == secureUUIDString {
                //logWrite(message: "Found Secure Peripheral: \(peripheral.name!)")
                logWrite(message: "Found Legacy Peripheral:\(peripheral.name!) UUID:\(peripheral.identifier.uuidString) RSSI:\(RSSI)")
                if self.discoveredPeripherals?.contains(peripheral) == false {
                    self.discoveredPeripherals?.append(peripheral)
                    self.securePeripheralMarkers?.append(true)
                    //discoveredPeripheralsTableView.reloadData()
                    
                    if(updatemode && device_address==peripheral.identifier.uuidString){
                        //Start DFU procedure
                        self.startDFU()
                    }
                }
            }else{
                logWrite(message: "Found Legacy Peripheral:\(peripheral.name!) UUID:\(peripheral.identifier.uuidString) RSSI:\(RSSI)")
                if self.discoveredPeripherals?.contains(peripheral) == false {
                    self.discoveredPeripherals?.append(peripheral)
                    self.securePeripheralMarkers?.append(false)
                    self.selectedPeripheral = peripheral
                    
                    if(updatemode && device_address==peripheral.identifier.uuidString){
                        //Start DFU procedure
                        self.startDFU()
                    }
                    
                }
            }
        }else{
            //logWrite(message: "END Scan. Device " + device_address + " not found")
            //exit(0)
        }
        
    }
    
    /**
     Callback function that runs when the app is closed
     */
    func applicationWillTerminate(_ aNotification: Notification) {
        logDebug(message: "applicationWillTerminate")
    }



}

